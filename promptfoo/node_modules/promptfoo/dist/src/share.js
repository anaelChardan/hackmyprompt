"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.determineShareDomain = determineShareDomain;
exports.stripAuthFromUrl = stripAuthFromUrl;
exports.createShareableUrl = createShareableUrl;
const input_1 = __importDefault(require("@inquirer/input"));
const chalk_1 = __importDefault(require("chalk"));
const cli_progress_1 = __importDefault(require("cli-progress"));
const url_1 = require("url");
const constants_1 = require("./constants");
const envars_1 = require("./envars");
const fetch_1 = require("./fetch");
const accounts_1 = require("./globalConfig/accounts");
const cloud_1 = require("./globalConfig/cloud");
const logger_1 = __importDefault(require("./logger"));
const cloud_2 = require("./util/cloud");
function determineShareDomain(eval_) {
    const sharing = eval_.config.sharing;
    logger_1.default.debug(`Share config: isCloudEnabled=${cloud_1.cloudConfig.isEnabled()}, sharing=${JSON.stringify(sharing)}, evalId=${eval_.id}`);
    const isPublicShare = !cloud_1.cloudConfig.isEnabled() && (!sharing || sharing === true || !('appBaseUrl' in sharing));
    const envAppBaseUrl = (0, envars_1.getEnvString)('PROMPTFOO_REMOTE_APP_BASE_URL');
    const domain = isPublicShare
        ? envAppBaseUrl || constants_1.DEFAULT_SHARE_VIEW_BASE_URL
        : cloud_1.cloudConfig.isEnabled()
            ? cloud_1.cloudConfig.getAppUrl()
            : typeof sharing === 'object' && sharing.appBaseUrl
                ? sharing.appBaseUrl
                : envAppBaseUrl || constants_1.DEFAULT_SHARE_VIEW_BASE_URL;
    logger_1.default.debug(`Share domain determined: domain=${domain}, isPublic=${isPublicShare}`);
    return { domain, isPublicShare };
}
const VERSION_SUPPORTS_CHUNKS = '0.103.8';
function isVersionGreaterOrEqual(a, b) {
    return a.localeCompare(b, undefined, { numeric: true }) !== -1;
}
async function getTargetOpenSourceServerVersion(apiHost) {
    const response = await (0, fetch_1.fetchWithProxy)(`${apiHost}/health`, {
        method: 'GET',
        headers: {
            'Content-Type': 'application/json',
        },
    });
    if (!response.ok) {
        return;
    }
    const { version } = await response.json();
    return version;
}
async function targetOpenSourceServerCanAcceptChunks(apiHost) {
    const version = await getTargetOpenSourceServerVersion(apiHost);
    return version != null && isVersionGreaterOrEqual(version, VERSION_SUPPORTS_CHUNKS);
}
async function targetHostCanUseNewResults(apiHost) {
    const version = await getTargetOpenSourceServerVersion(apiHost);
    return version != null;
}
// Helper functions
function getResultSize(result) {
    return Buffer.byteLength(JSON.stringify(result), 'utf8');
}
function calculateMedianResultSize(results, sampleSize = 25) {
    // Get the result size of the first sampleSize results
    const sampleSizes = results.slice(0, Math.min(sampleSize, results.length)).map(getResultSize);
    // Return the median result size
    return sampleSizes.sort((a, b) => a - b)[Math.floor(sampleSizes.length / 2)];
}
function createChunks(results, targetChunkSize) {
    const medianSize = calculateMedianResultSize(results);
    const estimatedResultsPerChunk = (0, envars_1.getEnvInt)('PROMPTFOO_SHARE_CHUNK_SIZE') ??
        Math.max(1, Math.floor(targetChunkSize / medianSize));
    logger_1.default.debug(`Median result size: ${medianSize} bytes, estimated results per chunk: ${estimatedResultsPerChunk}`);
    const chunks = [];
    for (let i = 0; i < results.length; i += estimatedResultsPerChunk) {
        chunks.push(results.slice(i, i + estimatedResultsPerChunk));
    }
    return chunks;
}
async function sendInitialEvalData(evalRecord, url, headers) {
    const evalDataWithoutResults = { ...evalRecord, results: [] };
    const response = await (0, fetch_1.fetchWithProxy)(url, {
        method: 'POST',
        headers,
        body: JSON.stringify(evalDataWithoutResults),
    });
    if (!response.ok) {
        throw new Error(`Failed to send initial eval data: ${response.statusText}`);
    }
    return (await response.json()).id;
}
async function sendChunkOfResults(chunk, url, evalId, headers) {
    const response = await (0, fetch_1.fetchWithProxy)(`${url}/${evalId}/results`, {
        method: 'POST',
        headers,
        body: JSON.stringify(chunk),
    });
    if (!response.ok) {
        const responseBody = await response.json();
        throw new Error(`Failed to send results chunk: ${response.statusText} = ${JSON.stringify(responseBody)}`);
    }
}
async function rollbackEval(url, evalId, headers) {
    await (0, fetch_1.fetchWithProxy)(`${url}/${evalId}`, { method: 'DELETE', headers });
}
async function sendChunkedResults(evalRecord, url) {
    await evalRecord.loadResults();
    const allResults = evalRecord.results;
    logger_1.default.debug(`Loaded ${allResults.length} results`);
    // Constants
    const TARGET_CHUNK_SIZE = 2 * 1024 * 1024; // 2MB in bytes
    // Calculate chunk sizes
    const medianSize = calculateMedianResultSize(allResults);
    logger_1.default.debug(`Median result size: ${medianSize} bytes`);
    // Create chunks
    const chunks = createChunks(allResults, TARGET_CHUNK_SIZE);
    // Prepare headers
    const headers = {
        'Content-Type': 'application/json',
    };
    if (cloud_1.cloudConfig.isEnabled()) {
        headers['Authorization'] = `Bearer ${cloud_1.cloudConfig.getApiKey()}`;
    }
    // Setup progress bar
    const progressBar = new cli_progress_1.default.SingleBar({
        format: 'Sharing | {bar} | {percentage}% | {value}/{total} results',
    }, cli_progress_1.default.Presets.shades_classic);
    progressBar.start(allResults.length, 0);
    try {
        // Send initial data and get eval ID
        const evalId = await sendInitialEvalData(evalRecord, url, headers);
        logger_1.default.debug(`Initial eval data sent successfully - ${evalId}`);
        // Send chunks
        logger_1.default.debug(`Sending ${chunks.length} requests to upload results`);
        try {
            for (const chunk of chunks) {
                await sendChunkOfResults(chunk, url, evalId, headers);
                progressBar.increment(chunk.length);
            }
        }
        catch (e) {
            logger_1.default.error(`Upload failed: ${e}`);
            logger_1.default.info(`Upload failed, rolling back...`);
            await rollbackEval(url, evalId, headers);
        }
        return evalId;
    }
    finally {
        progressBar.stop();
    }
}
async function sendEvalResults(evalRecord, url) {
    await evalRecord.loadResults();
    const headers = {
        'Content-Type': 'application/json',
    };
    if (cloud_1.cloudConfig.isEnabled()) {
        headers['Authorization'] = `Bearer ${cloud_1.cloudConfig.getApiKey()}`;
    }
    const response = await (0, fetch_1.fetchWithProxy)(url, {
        method: 'POST',
        headers,
        body: JSON.stringify(evalRecord),
    });
    if (!response.ok) {
        throw new Error(`Failed to send eval results: ${response.statusText}`);
    }
    const evalId = (await response.json()).id;
    return evalId;
}
/**
 * Removes authentication information (username and password) from a URL.
 *
 * This function addresses a security concern raised in GitHub issue #1184,
 * where sensitive authentication information was being displayed in the CLI output.
 * By default, we now strip this information to prevent accidental exposure of credentials.
 *
 * @param urlString - The URL string that may contain authentication information.
 * @returns A new URL string with username and password removed, if present.
 *          If URL parsing fails, it returns the original string.
 */
function stripAuthFromUrl(urlString) {
    try {
        const url = new url_1.URL(urlString);
        url.username = '';
        url.password = '';
        return url.toString();
    }
    catch {
        logger_1.default.warn('Failed to parse URL, returning original');
        return urlString;
    }
}
async function handleEmailCollection(evalRecord) {
    if (!process.stdout.isTTY || (0, envars_1.isCI)() || (0, envars_1.getEnvBool)('PROMPTFOO_DISABLE_SHARE_EMAIL_REQUEST')) {
        return;
    }
    let email = (0, accounts_1.getUserEmail)();
    if (!email) {
        email = await (0, input_1.default)({
            message: `${chalk_1.default.bold('Please enter your work email address')} (for managing shared URLs):`,
            validate: (value) => value.includes('@') || 'Please enter a valid email address',
        });
        (0, accounts_1.setUserEmail)(email);
    }
    evalRecord.author = email;
    await evalRecord.save();
}
async function getApiConfig(evalRecord) {
    if (cloud_1.cloudConfig.isEnabled()) {
        const apiBaseUrl = cloud_1.cloudConfig.getApiHost();
        return {
            apiBaseUrl,
            url: `${apiBaseUrl}/results`,
            sendInChunks: await (0, cloud_2.cloudCanAcceptChunkedResults)(),
        };
    }
    const apiBaseUrl = typeof evalRecord.config.sharing === 'object'
        ? evalRecord.config.sharing.apiBaseUrl || constants_1.SHARE_API_BASE_URL
        : constants_1.SHARE_API_BASE_URL;
    return {
        apiBaseUrl,
        url: `${apiBaseUrl}/api/eval`,
        sendInChunks: await targetOpenSourceServerCanAcceptChunks(apiBaseUrl),
    };
}
async function handleLegacyResults(evalRecord, url) {
    const summary = await evalRecord.toEvaluateSummary();
    const table = await evalRecord.getTable();
    const sharedResults = {
        data: {
            version: 3,
            createdAt: new Date().toISOString(),
            author: (0, accounts_1.getAuthor)(),
            results: { ...summary, table, version: 2 },
            config: evalRecord.config,
        },
    };
    const headers = {
        'Content-Type': 'application/json',
        ...(cloud_1.cloudConfig.isEnabled() && { Authorization: `Bearer ${cloud_1.cloudConfig.getApiKey()}` }),
    };
    const response = await (0, fetch_1.fetchWithProxy)(url, {
        method: 'POST',
        headers,
        body: JSON.stringify(sharedResults),
    });
    if (!response.ok) {
        logger_1.default.error(`Failed to create shareable URL: ${response.statusText}`);
        return null;
    }
    const responseJson = (await response.json());
    if (responseJson.error) {
        logger_1.default.error(`Failed to create shareable URL: ${responseJson.error}`);
        return null;
    }
    return responseJson.id ?? null;
}
async function createShareableUrl(evalRecord, showAuth = false) {
    // 1. Handle email collection
    await handleEmailCollection(evalRecord);
    // 2. Get API configuration
    const { apiBaseUrl, url, sendInChunks } = await getApiConfig(evalRecord);
    // 3. Determine if we can use new results format
    const canUseNewResults = cloud_1.cloudConfig.isEnabled() || (await targetHostCanUseNewResults(apiBaseUrl));
    logger_1.default.debug(`Sharing with ${url} canUseNewResults: ${canUseNewResults} Use old results: ${evalRecord.useOldResults()}`);
    // 4. Process and send results
    let evalId;
    if (!canUseNewResults || evalRecord.useOldResults()) {
        evalId = await handleLegacyResults(evalRecord, url);
    }
    else if (sendInChunks) {
        evalId = await sendChunkedResults(evalRecord, url);
    }
    else {
        evalId = await sendEvalResults(evalRecord, url);
    }
    if (!evalId) {
        return null;
    }
    logger_1.default.debug(`New eval ID on remote instance: ${evalId}`);
    const { domain } = determineShareDomain(evalRecord);
    // For custom self-hosted setups, ensure we're using the same domain as the API
    const customDomain = (0, envars_1.getEnvString)('PROMPTFOO_REMOTE_APP_BASE_URL');
    const finalDomain = customDomain || domain;
    const fullUrl = cloud_1.cloudConfig.isEnabled()
        ? `${finalDomain}/eval/${evalId}`
        : constants_1.SHARE_VIEW_BASE_URL === constants_1.DEFAULT_SHARE_VIEW_BASE_URL && !customDomain
            ? `${finalDomain}/eval/${evalId}`
            : `${finalDomain}/eval/?evalId=${evalId}`;
    return showAuth ? fullUrl : stripAuthFromUrl(fullUrl);
}
//# sourceMappingURL=share.js.map