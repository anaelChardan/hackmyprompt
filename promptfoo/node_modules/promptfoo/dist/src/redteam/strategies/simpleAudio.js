"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.textToAudio = textToAudio;
exports.addAudioToBase64 = addAudioToBase64;
const cli_progress_1 = require("cli-progress");
const logger_1 = __importDefault(require("../../logger"));
const invariant_1 = __importDefault(require("../../util/invariant"));
/**
 * Dynamically imports the node-gtts library
 * @returns The gTTS module or null if not available
 */
async function importGtts() {
    try {
        // Dynamic import of gtts
        return (await Promise.resolve().then(() => __importStar(require('node-gtts'))));
    }
    catch (error) {
        logger_1.default.warn(`node-gtts library not available: ${error}`);
        return null;
    }
}
/**
 * Converts text to an audio stream and then to base64 encoded string
 * using the node-gtts library which provides text-to-speech functionality
 */
async function textToAudio(text) {
    try {
        // Dynamically import gtts
        const gttsModule = await importGtts();
        if (!gttsModule) {
            throw new Error(`Please install node-gtts to use audio-based strategies: npm install node-gtts`);
        }
        // Initialize gtts with English language
        const gtts = gttsModule.default('en');
        // Get audio stream
        const audioStream = gtts.stream(text);
        // Collect stream data in chunks
        const chunks = [];
        // Convert stream to buffer using promises
        const buffer = await new Promise((resolve, reject) => {
            audioStream.on('data', (chunk) => chunks.push(chunk));
            audioStream.on('error', reject);
            audioStream.on('end', () => resolve(Buffer.concat(chunks)));
        });
        // Convert to base64
        return buffer.toString('base64');
    }
    catch (error) {
        logger_1.default.error(`Error generating audio from text: ${error}`);
        // Fallback to base64 encoding of the original text if audio generation fails
        return Buffer.from(text).toString('base64');
    }
}
/**
 * Adds audio encoding to test cases
 */
async function addAudioToBase64(testCases, injectVar) {
    const audioTestCases = [];
    let progressBar;
    if (logger_1.default.level !== 'debug') {
        progressBar = new cli_progress_1.SingleBar({
            format: 'Converting to Audio {bar} {percentage}% | ETA: {eta}s | {value}/{total}',
            hideCursor: true,
        }, cli_progress_1.Presets.shades_classic);
        progressBar.start(testCases.length, 0);
    }
    for (const testCase of testCases) {
        (0, invariant_1.default)(testCase.vars, `Audio encoding: testCase.vars is required, but got ${JSON.stringify(testCase)}`);
        const originalText = String(testCase.vars[injectVar]);
        // Convert text to audio and then to base64
        const base64Audio = await textToAudio(originalText);
        audioTestCases.push({
            ...testCase,
            assert: testCase.assert?.map((assertion) => ({
                ...assertion,
                metric: assertion.type?.startsWith('promptfoo:redteam:')
                    ? `${assertion.type?.split(':').pop() || assertion.metric}/Audio-Encoded`
                    : assertion.metric,
            })),
            vars: {
                ...testCase.vars,
                [injectVar]: base64Audio,
            },
            metadata: {
                ...testCase.metadata,
                strategyId: 'audio',
            },
        });
        if (progressBar) {
            progressBar.increment(1);
        }
        else {
            logger_1.default.debug(`Processed ${audioTestCases.length} of ${testCases.length}`);
        }
    }
    if (progressBar) {
        progressBar.stop();
    }
    return audioTestCases;
}
// Main function for direct testing via: npx tsx simpleAudio.ts "Text to convert to audio"
async function main() {
    // Get text from command line arguments or use default
    const textToConvert = process.argv[2] || 'This is a test of the audio encoding strategy.';
    logger_1.default.info(`Converting text to audio: "${textToConvert}"`);
    try {
        // Convert text to audio
        const base64Audio = await textToAudio(textToConvert);
        // Log the first 100 characters of the base64 audio to avoid terminal clutter
        logger_1.default.info(`Base64 audio (first 100 chars): ${base64Audio.substring(0, 100)}...`);
        logger_1.default.info(`Total base64 audio length: ${base64Audio.length} characters`);
        // Create a simple test case
        const testCase = {
            vars: {
                prompt: textToConvert,
            },
        };
        // Process the test case
        const processedTestCases = await addAudioToBase64([testCase], 'prompt');
        logger_1.default.info('Test case processed successfully.');
        logger_1.default.info(`Original prompt length: ${textToConvert.length} characters`);
        // Add type assertion to ensure TypeScript knows this is a string
        const processedPrompt = processedTestCases[0].vars?.prompt;
        logger_1.default.info(`Processed prompt length: ${processedPrompt.length} characters`);
        // Check if we're running this directly (not being imported)
        if (require.main === module) {
            // Write to a file for testing with audio players
            const fs = await Promise.resolve().then(() => __importStar(require('fs')));
            const outputFilePath = 'test-audio.mp3';
            // Decode base64 back to binary
            const audioBuffer = Buffer.from(base64Audio, 'base64');
            // Write binary data to file
            fs.writeFileSync(outputFilePath, audioBuffer);
            logger_1.default.info(`Audio file written to: ${outputFilePath}`);
            logger_1.default.info(`You can play it using any audio player to verify the conversion.`);
        }
    }
    catch (error) {
        logger_1.default.error(`Error generating audio from text: ${error}`);
    }
}
// Run the main function if this file is executed directly
if (require.main === module) {
    main();
}
//# sourceMappingURL=simpleAudio.js.map