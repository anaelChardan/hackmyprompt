"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GoogleMMLiveProvider = void 0;
const ws_1 = __importDefault(require("ws"));
const envars_1 = require("../envars");
const logger_1 = __importDefault(require("../logger"));
require("../util");
const util_1 = require("../util");
const shared_1 = require("./shared");
const vertexUtil_1 = require("./vertexUtil");
const formatContentMessage = (contents, contentIndex) => {
    if (contents[contentIndex].role != 'user') {
        throw new Error('Can only take user role inputs.');
    }
    if (contents[contentIndex].parts.length != 1) {
        throw new Error('Unexpected number of parts in user input.');
    }
    const userMessage = contents[contentIndex].parts[0].text;
    const contentMessage = {
        client_content: {
            turns: [
                {
                    role: 'user',
                    parts: [{ text: userMessage }],
                },
            ],
            turn_complete: true,
        },
    };
    return contentMessage;
};
class GoogleMMLiveProvider {
    constructor(modelName, options) {
        this.config = options.config;
        this.modelName = modelName;
    }
    id() {
        return `google:live:${this.modelName}`;
    }
    toString() {
        return `[Google Multimodal Live Provider ${this.modelName}]`;
    }
    getApiKey() {
        return this.config.apiKey || (0, envars_1.getEnvString)('GOOGLE_API_KEY');
    }
    async callApi(prompt, context) {
        // https://cloud.google.com/vertex-ai/docs/generative-ai/model-reference/gemini#gemini-pro
        if (!this.getApiKey()) {
            throw new Error('Google API key is not set. Set the GOOGLE_API_KEY environment variable or add `apiKey` to the provider config.');
        }
        let contents = (0, shared_1.parseChatPrompt)(prompt, [
            {
                role: 'user',
                parts: [
                    {
                        text: prompt,
                    },
                ],
            },
        ]);
        const { contents: updatedContents, coerced } = (0, vertexUtil_1.maybeCoerceToGeminiFormat)(contents);
        if (coerced) {
            logger_1.default.debug(`Coerced JSON prompt to Gemini format: ${JSON.stringify(contents)}`);
            logger_1.default.debug(`Coerced JSON prompt to Gemini format: ${JSON.stringify(updatedContents)}`);
            contents = updatedContents;
        }
        let contentIndex = 0;
        return new Promise((resolve) => {
            const url = `wss://generativelanguage.googleapis.com/ws/google.ai.generativelanguage.v1alpha.GenerativeService.BidiGenerateContent?key=${this.getApiKey()}`;
            const ws = new ws_1.default(url);
            const timeout = setTimeout(() => {
                ws.close();
                resolve({ error: 'WebSocket request timed out' });
            }, this.config.timeoutMs || 10000);
            let response_text_total = '';
            const function_calls_total = [];
            ws.onmessage = async (event) => {
                logger_1.default.debug(`Received WebSocket response: ${event.data}`);
                try {
                    let responseData;
                    if (typeof event.data === 'string') {
                        responseData = event.data;
                    }
                    else if (Buffer.isBuffer(event.data)) {
                        responseData = event.data.toString('utf-8');
                    }
                    else {
                        // Handle cases where event.data is of an unexpected type
                        logger_1.default.debug(`Unexpected event.data type: ${typeof event.data} ${event.data}`);
                        ws.close();
                        resolve({ error: 'Unexpected response data format' });
                        return;
                    }
                    const responseText = await new Response(responseData).text();
                    const response = JSON.parse(responseText);
                    // Handle setup complete response
                    if (response.setupComplete) {
                        const contentMessage = formatContentMessage(contents, contentIndex);
                        contentIndex += 1;
                        logger_1.default.debug(`WebSocket sent: ${JSON.stringify(contentMessage)}`);
                        ws.send(JSON.stringify(contentMessage));
                    }
                    // Handle model response
                    else if (response.serverContent?.modelTurn?.parts?.[0]?.text) {
                        response_text_total =
                            response_text_total + response.serverContent.modelTurn.parts[0].text;
                    }
                    else if (response.toolCall?.functionCalls) {
                        for (const functionCall of response.toolCall.functionCalls) {
                            function_calls_total.push(functionCall);
                            if (functionCall && functionCall.id && functionCall.name) {
                                let callbackResponse = {};
                                // Handle function tool callbacks
                                const functionName = functionCall.name;
                                if (this.config.functionToolCallbacks &&
                                    this.config.functionToolCallbacks[functionName]) {
                                    try {
                                        callbackResponse = await this.config.functionToolCallbacks[functionName](JSON.stringify(typeof functionCall.args === 'string'
                                            ? JSON.parse(functionCall.args)
                                            : functionCall.args));
                                    }
                                    catch (error) {
                                        callbackResponse = {
                                            error: `Error executing function ${functionName}: ${error}`,
                                        };
                                        logger_1.default.error(`Error executing function ${functionName}: ${error}`);
                                    }
                                }
                                const toolMessage = {
                                    tool_response: {
                                        function_responses: {
                                            id: functionCall.id,
                                            name: functionName,
                                            response: callbackResponse,
                                        },
                                    },
                                };
                                logger_1.default.debug(`WebSocket sent: ${JSON.stringify(toolMessage)}`);
                                ws.send(JSON.stringify(toolMessage));
                            }
                        }
                    }
                    else if (response.serverContent?.turnComplete) {
                        if (contentIndex < contents.length) {
                            const contentMessage = formatContentMessage(contents, contentIndex);
                            contentIndex += 1;
                            logger_1.default.debug(`WebSocket sent: ${JSON.stringify(contentMessage)}`);
                            ws.send(JSON.stringify(contentMessage));
                        }
                        else {
                            resolve({
                                output: JSON.stringify({
                                    text: response_text_total,
                                    toolCall: { functionCalls: function_calls_total },
                                }),
                            });
                            ws.close();
                        }
                    }
                }
                catch (err) {
                    logger_1.default.debug(`Failed to process response: ${JSON.stringify(err)}`);
                    ws.close();
                    resolve({ error: `Failed to process response: ${JSON.stringify(err)}` });
                }
            };
            ws.onerror = (err) => {
                clearTimeout(timeout);
                logger_1.default.debug(`WebSocket Error: ${err}`);
                ws.close();
                resolve({ error: `WebSocket error: ${JSON.stringify(err)}` });
            };
            ws.onclose = (event) => {
                clearTimeout(timeout);
            };
            ws.onopen = () => {
                logger_1.default.debug('WebSocket connection is opening...');
                const setupMessage = {
                    setup: {
                        model: `models/${this.modelName}`,
                        generation_config: {
                            context: this.config.context,
                            examples: this.config.examples,
                            stopSequence: this.config.stopSequence,
                            temperature: this.config.temperature,
                            maxOutputTokens: this.config.maxOutputTokens,
                            topP: this.config.topP,
                            topK: this.config.topK,
                            ...this.config.generationConfig,
                        },
                        ...(this.config.toolConfig ? { toolConfig: this.config.toolConfig } : {}),
                        ...(this.config.tools
                            ? {
                                tools: (0, util_1.maybeLoadFromExternalFile)((0, util_1.renderVarsInObject)(this.config.tools, context?.vars)),
                            }
                            : {}),
                        ...(this.config.systemInstruction
                            ? { systemInstruction: (0, util_1.maybeLoadFromExternalFile)(this.config.systemInstruction) }
                            : {}),
                    },
                };
                logger_1.default.debug(`WebSocket sent: ${JSON.stringify(setupMessage)}`);
                ws.send(JSON.stringify(setupMessage));
            };
        });
    }
}
exports.GoogleMMLiveProvider = GoogleMMLiveProvider;
//# sourceMappingURL=googleMultimodalLive.js.map